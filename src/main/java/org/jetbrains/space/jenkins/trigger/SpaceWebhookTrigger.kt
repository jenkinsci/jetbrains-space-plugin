package org.jetbrains.space.jenkins.trigger

import hudson.ExtensionList
import jenkins.model.*
import kotlinx.coroutines.runBlocking
import org.jetbrains.space.jenkins.config.*
import space.jetbrains.api.runtime.Option
import space.jetbrains.api.runtime.SpaceClient
import space.jetbrains.api.runtime.resources.applications
import space.jetbrains.api.runtime.resources.projects
import space.jetbrains.api.runtime.types.*
import space.jetbrains.api.runtime.types.partials.WebhookEventPartial
import java.util.logging.Level
import java.util.logging.Logger

/**
 * Ensures that webhook for this trigger is installed properly on the Space side.
 * The id of the resulting Space webhook is persisted along with the trigger parameters
 * to quickly match an arrived event with the webhook that caused it.
 *
 * The name of a generated webhook in Space has a special format so that it can be parsed back and matched to a trigger instance.
 * This format is defined in the [getSpaceWebhookName] function.
 *
 * Handling of the incoming webhook event is handled by the [SpaceWebhookEndpoint] class.
 */
fun SpaceWebhookTrigger.ensureAndGetSpaceWebhookId(jenkinsProjectName: String): String? {
    // id is autogenerated and should always be filled for a SpaceWebhookTrigger instance
    // if it's not, then the object is at an early initialization stage and its properties aren't filled with deserialized data yet
    if (id == null)
        return null

    val spaceConnection = ExtensionList.lookupSingleton(SpacePluginConfiguration::class.java).getConnectionById(spaceConnectionId)
    if (spaceConnection == null) {
        LOGGER.warning("Space connection not found by id = $spaceConnectionId")
        return null
    }

    return try {
        runBlocking {
            spaceConnection.getApiClient().use { spaceApiClient ->
                val existingWebhooks =
                    spaceApiClient.getRegisteredWebhooks().filter { it.webhook.name.startsWith("GEN|$id") }
                val webhookName = getSpaceWebhookName(projectKey, repositoryName, id)
                existingWebhooks
                    .filter { it.webhook.name != webhookName || triggerType == SpaceWebhookTriggerType.OnlySafeMerge }
                    .forEach {
                        spaceApiClient.applications.webhooks.deleteWebhook(
                            ApplicationIdentifier.Me,
                            it.webhook.id
                        )
                    }

                createSubscription(projectKey, repositoryName, spaceApiClient)?.let { subscription ->
                    spaceApiClient.ensureTriggerWebhook(
                        jenkinsProjectName = jenkinsProjectName,
                        projectKey = projectKey,
                        repositoryName = repositoryName,
                        triggerId = id,
                        subscription = subscription,
                        existingWebhooks = existingWebhooks
                    )
                }
            }
        }
    } catch (ex: Throwable) {
        LOGGER.log(Level.WARNING, "Error while setting up webhook in Space", ex)
        null
    }
}

/**
 * Generates an API model for feeding into Space API to create events subscription for a webhook.
 */
private suspend fun SpaceWebhookTrigger.createSubscription(projectKey: String, repositoryName: String, spaceApiClient: SpaceClient): CustomGenericSubscriptionIn? {
    val projectId = spaceApiClient.projects.getProject(ProjectIdentifier.Key(projectKey)).id
    return when (triggerType) {
        SpaceWebhookTriggerType.MergeRequests ->
            CustomGenericSubscriptionIn(
                subjectCode = "CodeReview",
                filters = listOf(CodeReviewSubscriptionFilterIn(
                    project = projectId,
                    repository = repositoryName,
                    authors = listOf(),
                    participants = listOf(),
                    branchSpec = splitBranchSpecs(mergeRequestSourceBranchSpec),
                    pathSpec = listOf(),
                    titleRegex = mergeRequestTitleRegex
                )),
                eventTypeCodes = listOfNotNull(
                    "CodeReview.Created".takeUnless { isMergeRequestApprovalsRequired },
                    "CodeReview.TitleUpdated".takeUnless { mergeRequestTitleRegex.isNullOrBlank() },
                    "CodeReview.CommitsUpdated",
                    "CodeReview.Participant.ChangesAccepted".takeIf { isMergeRequestApprovalsRequired }
                )
            )
        SpaceWebhookTriggerType.Branches ->
            CustomGenericSubscriptionIn(
                subjectCode = "Repository.Push",
                filters = listOf(RepoPushSubscriptionFilterIn(
                    projectId,
                    repositoryName,
                    RepoCommitsSubscriptionFilterSpec(
                        authors = emptyList(),
                        committers = emptyList(),
                        branchSpec = splitBranchSpecs(branchSpec),
                        pathSpec = "",
                        messageRegex = ""
                    )
                )),
                eventTypeCodes = listOf("Repository.Push.BranchCreated", "Repository.Push.BranchUpdated")
            )
        SpaceWebhookTriggerType.OnlySafeMerge ->
            null
    }
}

private fun splitBranchSpecs(spec: String?) =
    spec?.split(';')?.filterNot { it.isBlank() }?.takeUnless { it.isEmpty() }.orEmpty()

/**
 * Generates a name for the Space webhook from the trigger id, project key and repository name
 */
private fun getSpaceWebhookName(projectKey: String, repositoryName: String, triggerId: String): String {
    return "GEN|$triggerId|$projectKey|$repositoryName"
}

/**
 * Parses Space webhook name and extracts the trigger id from it
 */
fun getTriggerId(webhook: WebhookRecord): String? {
    return webhook.name.split('|').takeIf { it.size == 4 && it[0] == "GEN" }?.let { it[1] }
}

/**
 * Creates or updates Space webhook for the trigger according to the provided subscription settings.
 */
private suspend fun SpaceClient.ensureTriggerWebhook(
    jenkinsProjectName: String,
    projectKey: String,
    repositoryName: String,
    triggerId: String,
    subscription: CustomGenericSubscriptionIn,
    existingWebhooks: List<FullWebhookDTO>
): String {
    val webhookName = getSpaceWebhookName(projectKey, repositoryName, triggerId)
    val description = "Auto-generated webhook for triggering \"$jenkinsProjectName\" builds in Jenkins"
    val rootUrl = Jenkins.get().rootUrl
        ?: throw IllegalStateException("Jenkins instance has no root url specified")

    val triggerUrl = "${rootUrl.trimEnd('/')}/${SpaceWebhookEndpoint.URL}/process"

    val existing = existingWebhooks.firstOrNull { it.webhook.name == webhookName }
    return if (existing == null) {
        val webhookRecord = applications.webhooks.createWebhook(
            application = ApplicationIdentifier.Me,
            name = webhookName,
            description = description,
            endpoint = EndpointCreateDTO(triggerUrl, Jenkins.get().isRootUrlSecure),
            payloadFields = payloadFields,
            subscriptions = listOf(SubscriptionDefinition(webhookName, subscription))
        )
        webhookRecord.id
    } else {
        val webhookId = existing.webhook.id
        applications.webhooks.updateWebhook(
            application = ApplicationIdentifier.Me,
            webhookId = webhookId,
            name = webhookName,
            description = Option.Value(description),
            enabled = true,
            endpoint = Option.Value(
                ExternalEndpointUpdateDTO(Option.Value(triggerUrl), Jenkins.get().isRootUrlSecure)
            ),
            payloadFields = Option.Value(payloadFields)
        )

        val existingSubscriptions = applications.webhooks.subscriptions.getAllSubscriptions(
            ApplicationIdentifier.Me,
            webhookId
        )
        val subscriptionId: String
        if (existingSubscriptions.size == 1) {
            subscriptionId = existingSubscriptions[0].id
            applications.webhooks.subscriptions.updateSubscription(
                application = ApplicationIdentifier.Me,
                webhookId = webhookId,
                subscriptionId = subscriptionId,
                name = webhookName,
                enabled = true,
                subscription = subscription
            )
        } else {
            for (s in existingSubscriptions) {
                applications.webhooks.subscriptions.deleteSubscription(
                    ApplicationIdentifier.Me,
                    webhookId,
                    s.id
                )
            }
            val newSubscription = applications.webhooks.subscriptions.createSubscription(
                ApplicationIdentifier.Me,
                webhookId,
                webhookName,
                subscription
            )
            subscriptionId = newSubscription.id
        }

        applications.webhooks.subscriptions.requestMissingRights(
            ApplicationIdentifier.Me, webhookId, subscriptionId
        )
        webhookId
    }
}

/**
 * This lambda uses the DSL defined in Space SDK to list the properties that should be included
 * in the payload of the webhook event that Space sends to Jenkins.
 */
private val payloadFields: WebhookEventPartial.() -> Unit = {
    // common fields
    meta()
    projectKey { key() }
    repository()

    // git push events
    head()
    oldCommitId()
    newCommitId()
    created()
    deleted()
    forced()

    // code review events
    titleMod {
        old()
        new()
    }
    reviewerState()
    review {
        id()
        projectId()
        project { key() }
        number()
        title()
        branchPairs {
            repository()
            sourceBranchInfo()
            targetBranchInfo()
        }
        participants {
            role()
            state()
        }
    }
}

/**
 * Fetches all webhooks registered for Jenkins integration on the Space side
 */
suspend fun SpaceClient.getRegisteredWebhooks(): List<FullWebhookDTO> {
    return applications.webhooks.getAllWebhooks(ApplicationIdentifier.Me) {
        webhook {
            id()
            name()
        }
    }.data
}

private val LOGGER = Logger.getLogger(SpaceWebhookTrigger::class.java.name)

package org.jetbrains.space.jenkins.trigger

import jenkins.branch.MultiBranchProject
import jenkins.model.*
import kotlinx.coroutines.runBlocking
import org.jetbrains.space.jenkins.SpacePayloadHandler
import org.jetbrains.space.jenkins.*
import org.jetbrains.space.jenkins.config.SpaceProjectConnection
import org.jetbrains.space.jenkins.config.getApiClient
import org.jetbrains.space.jenkins.scm.SpaceSCMSource
import org.jetbrains.space.jenkins.scm.getWebhookDefinition
import space.jetbrains.api.runtime.Option
import space.jetbrains.api.runtime.SpaceClient
import space.jetbrains.api.runtime.resources.applications
import space.jetbrains.api.runtime.resources.projects
import space.jetbrains.api.runtime.types.*
import space.jetbrains.api.runtime.types.partials.WebhookEventPartial
import java.util.logging.Level
import java.util.logging.Logger

/**
 * Ensures that webhook for this trigger is installed properly on the SpaceCode side.
 * The id of the resulting SpaceCode webhook is persisted along with the trigger parameters
 * to quickly match an arrived event with the webhook that caused it.
 *
 * Handling of the incoming webhook event is handled by the [SpacePayloadHandler] class.
 */
fun SpaceWebhookTrigger.ensureAndGetSpaceWebhookId(): String? {
    // id is autogenerated and should always be filled for a SpaceWebhookTrigger instance
    // if it's not, then the object is at an early initialization stage and its properties aren't filled with deserialized data yet
    if (id == null)
        return null

    val (spaceConnection, spaceUrl) = job.getProjectConnection()
        ?: run {
            LOGGER.warning("SpaceCode project-level connection not found for the job")
            return null
        }

    return getDefinition().ensureSpaceWebhook(spaceUrl, spaceConnection, repositoryName, id)
}

fun SpaceSCMSource.ensureAndGetSpaceWebhookId(): String? {
    val multiBranchProject = (owner as? MultiBranchProject<*,*>) ?: return null
    val (spaceConnection, spaceUrl) = multiBranchProject.getProjectConnection(spaceConnectionId, projectKey)
        ?: run {
            LOGGER.warning("SpaceCode project-level connection not found for the SCM branch source")
            return null
        }

    return getWebhookDefinition().ensureSpaceWebhook(spaceUrl, spaceConnection, repository, id)
}

private const val SPACE_WEBHOOK_NAME = "(generated) Trigger build in Jenkins"

private fun SpaceWebhookTriggerDefinition?.ensureSpaceWebhook(
    spaceUrl: String,
    spaceConnection: SpaceProjectConnection,
    repositoryName: String,
    jenkinsProjectName: String
): String? = try {
    runBlocking {
        spaceConnection.getApiClient(spaceUrl).use { spaceApiClient ->
            val existingWebhook = spaceApiClient.getRegisteredWebhooks().firstOrNull {
                it.webhook.name == SPACE_WEBHOOK_NAME
            }

            if (this@ensureSpaceWebhook != null) {
                createSubscription(spaceConnection.projectKey, repositoryName, spaceApiClient)
                    ?.let { subscription ->
                        spaceApiClient.ensureTriggerWebhook(
                            jenkinsProjectName = jenkinsProjectName,
                            subscription = subscription,
                            existing = existingWebhook
                        )
                    }
            } else {
                if (existingWebhook != null) {
                    spaceApiClient.applications.webhooks.deleteWebhook(ApplicationIdentifier.Me, existingWebhook.webhook.id)
                }
                null
            }
        }
    }
} catch (ex: Throwable) {
    LOGGER.log(Level.WARNING, "Error while setting up webhook in SpaceCode", ex)
    null
}

/**
 * Prepares input data for creating a webhook in SpaceCode for a given job trigger
 */
fun SpaceWebhookTrigger.getDefinition() =
    when (triggerType) {
        SpaceWebhookTriggerType.Branches ->
            SpaceWebhookTriggerDefinition.Branches(branchSpec)

        SpaceWebhookTriggerType.MergeRequests ->
            SpaceWebhookTriggerDefinition.MergeRequests(
                titleRegex = mergeRequestTitleRegex,
                sourceBranchSpec = mergeRequestSourceBranchSpec,
                targetBranchSpec = "",
                isMergeRequestApprovalsRequired = isMergeRequestApprovalsRequired
            )

        SpaceWebhookTriggerType.OnlySafeMerge ->
            null
    }

/**
 * Generates an API model for feeding into SpaceCode API to create events subscription for a webhook.
 */
private suspend fun SpaceWebhookTriggerDefinition.createSubscription(projectKey: String, repositoryName: String, spaceApiClient: SpaceClient): CustomGenericSubscriptionIn? {
    val projectId = spaceApiClient.projects.getProject(ProjectIdentifier.Key(projectKey)).id
    return when (this) {
        is SpaceWebhookTriggerDefinition.MergeRequests ->
            CustomGenericSubscriptionIn(
                subjectCode = "CodeReview",
                filters = listOf(CodeReviewSubscriptionFilterIn(
                    project = projectId,
                    repository = repositoryName,
                    authors = listOf(),
                    participants = listOf(),
                    branchSpec = splitBranchSpecs(sourceBranchSpec),
                    pathSpec = listOf(),
                    titleRegex = titleRegex.orEmpty()
                )),
                eventTypeCodes = listOfNotNull(
                    "CodeReview.Created".takeUnless { isMergeRequestApprovalsRequired },
                    "CodeReview.TitleUpdated".takeUnless { titleRegex.isNullOrBlank() },
                    "CodeReview.CommitsUpdated",
                    "CodeReview.Participant.ChangesAccepted".takeIf { isMergeRequestApprovalsRequired }
                )
            )
        is SpaceWebhookTriggerDefinition.Branches ->
            CustomGenericSubscriptionIn(
                subjectCode = "Repository.Push",
                filters = listOf(RepoPushSubscriptionFilterIn(
                    projectId,
                    repositoryName,
                    RepoCommitsSubscriptionFilterSpec(
                        authors = emptyList(),
                        committers = emptyList(),
                        branchSpec = splitBranchSpecs(branchSpec),
                        pathSpec = "",
                        messageRegex = ""
                    )
                )),
                eventTypeCodes = listOf("Repository.Push.BranchCreated", "Repository.Push.BranchUpdated")
            )
    }
}

private fun splitBranchSpecs(spec: String?) =
    spec?.split(';')?.filterNot { it.isBlank() }?.takeUnless { it.isEmpty() }.orEmpty()

/**
 * Creates or updates SpaceCode webhook for the trigger according to the provided subscription settings.
 */
private suspend fun SpaceClient.ensureTriggerWebhook(
    jenkinsProjectName: String,
    subscription: CustomGenericSubscriptionIn,
    existing: FullWebhookDTO?
): String {
    val description = "Auto-generated webhook for triggering \"$jenkinsProjectName\" builds in Jenkins"
    val rootUrl = Jenkins.get().rootUrl
        ?: throw IllegalStateException("Jenkins instance has no root url specified")

    val triggerUrl = "${rootUrl.trimEnd('/')}/${SpacePayloadHandler.URL}/process"

    return if (existing == null) {
        val webhookRecord = applications.webhooks.createWebhook(
            application = ApplicationIdentifier.Me,
            name = SPACE_WEBHOOK_NAME,
            description = description,
            endpoint = EndpointCreateDTO(triggerUrl, Jenkins.get().isRootUrlSecure),
            payloadFields = payloadFields,
            subscriptions = listOf(SubscriptionDefinition(SPACE_WEBHOOK_NAME, subscription))
        )
        webhookRecord.id
    } else {
        val webhookId = existing.webhook.id
        applications.webhooks.updateWebhook(
            application = ApplicationIdentifier.Me,
            webhookId = webhookId,
            name = SPACE_WEBHOOK_NAME,
            description = Option.Value(description),
            enabled = true,
            endpoint = Option.Value(
                ExternalEndpointUpdateDTO(Option.Value(triggerUrl), Jenkins.get().isRootUrlSecure)
            ),
            payloadFields = Option.Value(payloadFields)
        )

        val existingSubscriptions = applications.webhooks.subscriptions.getAllSubscriptions(
            ApplicationIdentifier.Me,
            webhookId
        )
        val subscriptionId: String
        if (existingSubscriptions.size == 1) {
            subscriptionId = existingSubscriptions[0].id
            applications.webhooks.subscriptions.updateSubscription(
                application = ApplicationIdentifier.Me,
                webhookId = webhookId,
                subscriptionId = subscriptionId,
                name = SPACE_WEBHOOK_NAME,
                enabled = true,
                subscription = subscription
            )
        } else {
            for (s in existingSubscriptions) {
                applications.webhooks.subscriptions.deleteSubscription(
                    ApplicationIdentifier.Me,
                    webhookId,
                    s.id
                )
            }
            val newSubscription = applications.webhooks.subscriptions.createSubscription(
                ApplicationIdentifier.Me,
                webhookId,
                SPACE_WEBHOOK_NAME,
                subscription
            )
            subscriptionId = newSubscription.id
        }

        applications.webhooks.subscriptions.requestMissingRights(
            ApplicationIdentifier.Me, webhookId, subscriptionId
        )
        webhookId
    }
}

/**
 * This lambda uses the DSL defined in Space SDK to list the properties that should be included
 * in the payload of the webhook event that SpaceCode sends to Jenkins.
 */
private val payloadFields: WebhookEventPartial.() -> Unit = {
    // common fields
    meta()
    projectKey { key() }
    repository()

    // git push events
    head()
    oldCommitId()
    newCommitId()
    created()
    deleted()
    forced()

    // code review events
    titleMod {
        old()
        new()
    }
    reviewerState()
    review {
        id()
        projectId()
        project { key() }
        number()
        title()
        branchPairs {
            repository()
            sourceBranchInfo()
            targetBranchInfo()
        }
        participants {
            role()
            state()
        }
    }
}

/**
 * Fetches all webhooks registered for Jenkins integration on the SpaceCode side
 */
suspend fun SpaceClient.getRegisteredWebhooks(): List<FullWebhookDTO> {
    return applications.webhooks.getAllWebhooks(ApplicationIdentifier.Me) {
        webhook {
            id()
            name()
        }
    }.data
}

private val LOGGER = Logger.getLogger(SpaceWebhookTrigger::class.java.name)
